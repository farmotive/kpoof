#!/bin/bash
#
# See usage().

[[ -n $DEBUG ]] && set -x

set -eou pipefail
IFS=$'\n\t'

NOW=$(date +"%F")
NOWT=$(date +"%T")
APPDIR="${HOME}"/.kpoof
DAEMONSFILE="${APPDIR}"/kpoofd
LOGFILE=${APPDIR}/kpoof-${NOW}-${NOWT}.log

# We do this so the called script name variable is available in utility functions
# below, in case of name change, brew alias, etc.
SCRIPT=`basename ${BASH_SOURCE[0]}`

usage() {
  cat <<EOF
${SCRIPT}(1)

NAME
    ${SCRIPT} - Quick k8s pod port-forward utility.

REQUIRES
    kubectl(1)

SYNOPSIS
    ${SCRIPT} [OPTIONS]

DESCRIPTION
    ${SCRIPT} is a quick kubernetes (k8s) utility to port-forward a pod to localhost (127.0.0.1). ${SCRIPT} prompts for:
      - <NAMESPACE> (defaults to current ns. See kubens(1))
      - <POD> (defaults to "1")
      - <LOCAL_PORT> (If "-p" or "--port" is envoked, designate an available local port. Defaults to the first exposed port of the pod)
      - <REMOTE_PORT> (If "-p" or "--port" is envoked, select from the list of remote ports to forward.)
    ENTER to use defaults.

OPTIONS
    -h, --help
        Show this help message
    -p, --port
        Port-forwards to a lone port on the remote host
    -d, --daemon
        Runs kpoof command as a daemon
    -k, --killd
        Kills a kpoof command daemon, if running
    -a, --killd-all
        Kills all running kpoof command daemons defined in $HOME/.kpoof/kpoofd

SEE ALSO
    kubectx(1), kubens(1), kex(1)
EOF
}

ns_current() {
  # Borrowed partly from kubens current_namespace().
  cur_ctx=$(kubectl config current-context)
  echo "$(kubectl config view -o=jsonpath="{.contexts[?(@.name==\"${cur_ctx}\")].context.namespace}")"
}

ns_param() {
  local ns=$(ns_select)
  if [[ ! -z ${ns:-} ]]; then
    echo "--namespace=${ns}"
  fi
}

ns_list() {
  kubectl get namespaces -o=jsonpath='{range .items[*].metadata.name}{@}{"\n"}{end}'
}

ns_number_list() {
  ns_list | nl
}

ns_select() {
  if [[ ! -z ${NS:-} ]]; then
    ns_list | sed -n ${NS}p
  elif [[ ! -z ${NAMESPACE:-} ]]; then
    echo $NAMESPACE
  else
    ns_current
  fi
}

po_list() {
  kubectl $(ns_param) \
    get pods \
    -o=jsonpath='{range .items[*].metadata.name}{@}{"\n"}{end}'
}

po_number_list() {
  po_list | nl
}

po_select() {
  po_list | sed -n ${POD:-1}p
}

port_list() {
  kubectl get po $(ns_param) $(po_select)\
  -o=jsonpath='{..containerPort}' \
  | tr " " "\n" \
  | sort -u
}

# Because *nix denies binding to ports below 1001, we assign a port of N+50000,
# where `n` is a sub-1001 port. Much better to adhere to the security protocol
# than to manipulate the bash binary.
# See second caveat: https://stackoverflow.com/a/414258/4096495
port_check() {
  if [[ $1 -lt 1001 ]]; then
    echo "$(($1+50000))";
  else
    echo $1;
  fi
}

port_x() {
  for i in $(port_list); do
    echo $(port_check $i):${i}
  done
}

port_number_list() {
  port_list | nl
}

port_sniff() {
  port_list | sed -n ${REMOTE_PORT:-1}p
}

po_pf() {
  local LOCAL_CHECK=$(port_check ${LOCAL_PORT:-$(port_sniff)})
  local CMD="kubectl port-forward $(ns_param) $(po_select) $LOCAL_CHECK:${REMOTE_PORT:-$(port_sniff)}"
  if [ ! -z "${KILLD:-}" ]; then killd ${CMD}; exit 0; fi
  checkdaemon ${CMD}
}

po_pf_all() {
  # Store CMD as an array, because passing strings with colons is unpredictable.
  local CMD=(kubectl port-forward $(ns_param) $(po_select) $(port_x))
  if [ ! -z "${KILLD:-}" ]; then killd "${CMD[@]}"; exit 0; fi
  checkdaemon "${CMD[@]}"
}

# Requires daemon process CMD array as argument.
killd() {
  CMD=("$@")
  STRING=$(printf ' %q' "${CMD[@]}"  | sed -e 's/^[[:space:]]*//')
  local PID=$(ps -aef | grep $STRING | grep -v grep | awk '{print $2}')
  if [ ! -z "${PID}" ]; then
    kill -9 ${PID} || true
  fi

  # Remove CMD entry from daemon file.
  local TMPFILE="${APPDIR}"/kpoofd.tmp
  if [ -f $DAEMONSFILE ]; then
    awk -v cmd=$STRING '$0!=cmd {print $0}' $DAEMONSFILE > $TMPFILE && mv $TMPFILE $DAEMONSFILE
  fi
}

killdall() {
  if [ -f $DAEMONSFILE ]; then
    while read CMD;
    do
      killd ${CMD}
    done < $DAEMONSFILE
    rm $DAEMONSFILE
  fi
}

# Requires daemon process CMD array as argument.
checkdaemon() {
  CMD=("$@")
  if [ ! -z "${DAEMON:-}" ]; then
    daemon "${CMD[@]}"
  else
    "${CMD[@]}"
  fi
}

# Requires daemon process CMD array as argument.
# Each daemon CMD (see `man ps`) consists of a unique `kubectl port-forward`
# command string, represented in this argument as an array.
daemon() {
  CMD=("$@")
  STRING=$(printf ' %q' "${CMD[@]}"  | sed -e 's/^[[:space:]]*//')
  # Always kill any running version of this exact process to avoid port-forward
  # conflicts.
  # Note that we could alternatively check whether the process is already
  # running, and if so, not bother killing/restarting the daemon. owever, if the
  # earlier running process is running but no longer works, then the user would
  # need to `kpoof -k` to kill it and then `kpoof -d` to start it again. Since
  # the port-forward process is quick to both kill and start, we do it for the
  # user automatically to save manual checking and frustration.
  killd "${CMD[@]}"

  # Start daemon.
  "${CMD[@]}" > ${LOGFILE} 2>&1 &

  # Add to list of running daemons.
  echo $STRING >> ${DAEMONSFILE}
}

initappdir() {
  mkdir -p ${APPDIR}
}

# Transform long options to short ones. Sick trick.
# http://stackoverflow.com/a/30026641/4096495
for arg in "$@"; do
  shift
  case "$arg" in
    "--help")       set -- "$@" "-h" ;;
    "--port")       set -- "$@" "-p" ;;
    "--daemon")     set -- "$@" "-d" ;;
    "--killd")      set -- "$@" "-k" ;;
    "--killd-all")  set -- "$@" "-a" ;;
    *)              set -- "$@" "$arg"
  esac
done

while getopts :phdka OPT; do
  case $OPT in
    h ) HELP=true;;
    p ) PORT=true;;
    d ) DAEMON=true;;
    k ) KILLD=true;;
    a ) KILLDALL=true;;
    \?) echo "Unknown option: -$OPTARG" >&2; exit 1;;
    : ) echo "Missing option argument for -$OPTARG" >&2; exit 1;;
  esac
done
shift $((OPTIND-1))

# Help and port-forward should not happen simultaneously, so elif.
if [[ ${HELP:-} == 'true' ]]; then
  usage; exit 0
elif [[ ${KILLDALL:-} == 'true' ]]; then
  killdall; exit 0
else
  initappdir
  ns=$(ns_current)
  echo "Namespace? (default ${ns:-default}):"; ns_number_list; read NS;
  echo 'Pod number? (default 1):'; po_number_list; read POD;

  if [[ ${PORT:-} == 'true' ]]; then
    echo 'Remote port number? (default 1):'; port_number_list; read REMOTE_PORT;
    echo "Local port number? (defaults to $(port_sniff)):"; read LOCAL_PORT;
    po_pf
  else
    po_pf_all
  fi
fi
